<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://zeroxln.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="zerohacker.me">
<meta property="og:url" content="https://zeroxln.github.io/index.html">
<meta property="og:site_name" content="zerohacker.me">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZeroX">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zeroxln.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>zerohacker.me</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zerohacker.me</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/08/25/ubuntu%E9%85%8D%E7%BD%AEClash%E7%BF%BB%E5%A2%99%E5%B9%B6%E8%AE%BF%E9%97%AETelegram/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/ubuntu%E9%85%8D%E7%BD%AEClash%E7%BF%BB%E5%A2%99%E5%B9%B6%E8%AE%BF%E9%97%AETelegram/" class="post-title-link" itemprop="url">ubuntu配置Clash翻墙并访问Telegram</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-25 11:27:28 / 修改时间：12:18:03" itemprop="dateCreated datePublished" datetime="2020-08-25T11:27:28+08:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、申请账号</p>
<p>在<a href="http://999yun.club/login上购买相应的服务，在个人中心-服务订阅部分选择复制地址，打开左侧的订阅转换中心，粘贴该地址，选择clash进行转换，将转换后的地址复制到clash" target="_blank" rel="noopener">http://999yun.club/login上购买相应的服务，在个人中心-服务订阅部分选择复制地址，打开左侧的订阅转换中心，粘贴该地址，选择clash进行转换，将转换后的地址复制到clash</a> for windows左侧栏的Profiles的输入框里，点击Download，将最新的yml打开并复制到一个新的文本文件中，重命名为config.yml，之后再ubuntu上直接使用这个作为配置文件</p>
<p>二、安装clash for linux</p>
<p>1.从<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FDreamacro%2Fclash%2Freleases" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/releases</a>下载相应的clash可执行程序，我下载的是clash-linux-amd64-v1.1.0.gz</p>
<p>2.解压，直接运行解压出的程序，会创建一个config.yml，并下载Country.mmdb文件，这个config.yml之后需要修改</p>
<p>3.删除掉Ubuntu上的原始config.yml，使用第一步中的config.yml</p>
<p>参考链接：<a href="https://www.jianshu.com/p/2906066d2e0a" target="_blank" rel="noopener">https://www.jianshu.com/p/2906066d2e0a</a></p>
<p>三、配置代理</p>
<p>1.修改完config.yml后，重新运行clash-linux-amd64，</p>
<p>2.使用浏览器访问<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fclash.razord.top" target="_blank" rel="noopener">http://clash.razord.top</a> </p>
<p>3.打开系统的网络代理，根据config.yml中的配置，如下编辑</p>
<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200825121429765.png" alt="image-20200825121429765"></p>
<p>4.之后设置浏览器的网络代理，基本上选择使用系统代理就行</p>
<p>四、Telegram代理</p>
<p>打开Telegram，点击左下角的代理设置Proxy settings</p>
<p>选择Use custom proxy，配置SOCKS5，基本如下</p>
<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200825121707418.png" alt="image-20200825121707418"></p>
<p>之后就可以尽情享用Telegram啦</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/08/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC2%E7%89%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC2%E7%89%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/" class="post-title-link" itemprop="url">算法竞赛入门经典(第2版) 读书笔记(一)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 10:37:19" itemprop="dateCreated datePublished" datetime="2020-08-25T10:37:19+08:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/06/22/Memory-Layout-of-C-Programs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/Memory-Layout-of-C-Programs/" class="post-title-link" itemprop="url">Memory Layout of C Programs</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 17:55:46" itemprop="dateCreated datePublished" datetime="2020-06-22T17:55:46+08:00">2020-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-23 15:07:46" itemprop="dateModified" datetime="2020-06-23T15:07:46+08:00">2020-06-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Memory-Layout-of-C-Programs"><a href="#Memory-Layout-of-C-Programs" class="headerlink" title="Memory Layout of C Programs"></a>Memory Layout of C Programs</h1><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg" alt="img"></p>
<p>C程序的典型内存表示分为如下几个区：</p>
<ol>
<li>Text segment</li>
<li>初始化数据区</li>
<li>未初始化数据区</li>
<li>栈区</li>
<li>堆区</li>
</ol>
<h4 id="Text-segment"><a href="#Text-segment" class="headerlink" title="Text segment"></a>Text segment</h4><p>文本段，也称为代码段或简单地称为文本，是程序在目标文件或内存中的一个部分。其中包含可执行指令。<br>作为一段内存区域，文本段可以放在堆或堆栈的下面，以防止堆和堆栈溢出覆盖它。</p>
<p>通常，文本段是可共享的，因此对于经常执行的程序（如ext编辑器、C编译器、shell等），只需要在内存中有一个副本。此外，文本段通常是只读的，以防止程序意外地修改其指令</p>
<blockquote>
<p>A text segment , also known as a code segment or simply as text, is one of the sections of a program in an object file or in memory, which contains executable instructions.</p>
<p>As a memory region, a text segment may be placed below the heap or stack in order to prevent heaps and stack overflows from overwriting it.</p>
<p>Usually, the text segment is sharable so that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. Also, the text segment is often read-only, to prevent a program from accidentally modifying its instructions.</p>
</blockquote>
<h4 id="Initialized-Data-Segment"><a href="#Initialized-Data-Segment" class="headerlink" title="Initialized Data Segment"></a>Initialized Data Segment</h4><p>初始化的数据段，通常简称为数据段。数据段是程序虚拟地址空间的一部分，它包含由程序员初始化的全局变量和静态变量<br>注意，数据段不是只读的，因为变量的值可以在运行时更改<br>此段可进一步分为初始化只读区和初始化读写区<br>例如，由C中的char sl=“hello world”定义的全局字符串和main（e global）之外的int debug=1这样的C语句将存储在初始化的读写区域中。而像const char*string=“hello world”这样的全局C语句使字符串文字“hello world存储在初始化只读区域，字符指针变量字符串存储在初始化读写区域<br>Example：静态int i=10存储在数据段中，全局int i=10也存储在数据段中</p>
<blockquote>
<p>Initialized data segment, usually called simply the Data Segment. A data segment is a portion of virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer.</p>
<p>Note that, data segment is not read-only, since the values of the variables can be altered at run time.</p>
<p>This segment can be further classified into initialized read-only area and initialized read-write area.</p>
<p>For instance the global string defined by char s[] = “hello world” in C and a C statement like int debug=1 outside the main (i.e. global) would be stored in initialized read-write area. And a global C statement like const char* string = “hello world” makes the string literal “hello world” to be stored in initialized read-only area and the character pointer variable string in initialized read-write area.</p>
<p>Ex: static int i = 10 will be stored in data segment and global int i = 10 will also be stored in data segment</p>
</blockquote>
<h4 id="Uninitialized-Data-Segment"><a href="#Uninitialized-Data-Segment" class="headerlink" title="Uninitialized Data Segment"></a>Uninitialized Data Segment</h4><p>未初始化的数据段，通常称为“bss段”，以一个古老的汇编运算符命名，该运算符代表“由该段中的符号数据开始的块”，在程序开始执行之前，内核将其初始化为算术0<br>未初始化的数据从数据段的末尾开始，包含所有初始化为零或在源代码中没有显式初始化的全局变量和静态变量<br>例如，声明为static int i的变量将包含在BSS段中，或者声明为int j的全局变量将包含在BSS段中</p>
<blockquote>
<p>Uninitialized data segment, often called the “bss” segment, named after an ancient assembler operator that stood for “block started by symbol.” Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing</p>
<p>uninitialized data starts at the end of the data segment and contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code.</p>
<p>For instance a variable declared static int i; would be contained in the BSS segment.<br>For instance a global variable declared int j; would be contained in the BSS segment.</p>
</blockquote>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>堆栈区域通常与堆区域相邻，并在堆栈指针遇到堆指针时向相反方向增长，从而耗尽可用内存。（有了现代的大地址空间和虚拟内存技术，它们几乎可以放在任何地方，但它们通常还是朝相反的方向发展。<br>堆栈区包含程序堆栈的后进先出结构，通常位于内存的较高部分。在标准的PC 86计算机体系结构上，它朝着地址零的方向发展，而在其他一些体系结构上，它朝着相反的方向发展。一个“堆栈指针”寄存器跟踪堆栈的顶部：每次将一个值“推送到堆栈上”时都会对其进行调整。为一个函数调用推送的值集称为堆栈帧堆栈帧至少包含一个返回地址<br>堆栈，其中存储自动变量，以及每次调用函数时保存的信息。每次调用一个函数时，要返回到哪里的地址和有关调用者环境的某些信息（例如某些计算机寄存器）都会保存在堆栈中。然后，新调用的函数在堆栈上为其自动和临时变量分配空间。这就是C中递归函数的工作原理。每次递归函数调用自身时，都会使用一个新的堆栈帧，这样一组变量就不会干扰函数另一个实例中的变量</p>
<blockquote>
<p>The stack area traditionally adjoined the heap area and grew the opposite direction; when the stack pointer met the heap pointer, free memory was exhausted. (With modern large address spaces and virtual memory techniques they may be placed almost anywhere, but they still typically grow opposite directions.)</p>
<p>The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory. On the standard PC x86 computer architecture it grows toward address zero; on some other architectures it grows the opposite direction. A “stack pointer” register tracks the top of the stack; it is adjusted each time a value is “pushed” onto the stack. The set of values pushed for one function call is termed a “stack frame”; A stack frame consists at minimum of a return address.</p>
<p>Stack, where automatic variables are stored, along with information that is saved each time a function is called. Each time a function is called, the address of where to return to and certain information about the caller’s environment, such as some of the machine registers, are saved on the stack. The newly called function then allocates room on the stack for its automatic and temporary variables. This is how recursive functions in C can work. Each time a recursive function calls itself, a new stack frame is used, so one set of variables doesn’t interfere with the variables from another instance of the function.</p>
</blockquote>
<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>堆是动态内存分配通常发生的段<br>堆区域从BSS段的末尾开始，并从那里增长到更大的地址。堆区域由malloc、realloc和free管理，后者可以使用brk和sbrk系统调用来调整其大小（注意，使用brk/sbrk和单个堆区域“不需要满足malloc/realloc/free的契约，它们也可以使用mmap来实现，以将虚拟内存中可能不连续的区域保留到进程的虚拟地址空间中）。堆区域由进程中的所有共享库和动态加载的模块共享<br>size(1)命令报告文本、数据和bss段的大小（字节）。（有关详细信息，请参考size(1)的man文档)</p>
<p>1.可以查看以下简单C程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623103610753.png" alt="image-20200623103610753"></p>
<p>2.添加一个全局变量，再次检查bss的大小</p>
<p><font color=red>:( ParrotSec添加int global; bss未发生变化，按理来说应该是<strong>12</strong></font></p>
<p>3.再添加一个静态变量，也会被存储在bss段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line"><span class="comment">//ParrotSec添加int global; bss未发生变化，按理来说应该是12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">/*Uninitialized static variable stored in bss*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623103936264.png" alt="image-20200623103936264"></p>
<p>4.让我们来初始化这个静态变量看看，注意哈，这时，它将会被放在<strong>Data Segment(DS)数据段</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>; <span class="comment">/* Initialized static variable stored in DS*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623110357519.png" alt="image-20200623110357519"></p>
<p>问题：</p>
<p>这是在centos上编译出来的效果</p>
<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623110617166.png" alt="image-20200623110617166"></p>
<p><font color=purple><strong>Q:</strong> 对同一个程序，为什么不同的机器上会出现size不同的情况？</font></p>
<p>size</p>
<ul>
<li>text  –  Actual machine instructions that your CPU going to execute. Linux allows to share this data.</li>
<li>data  –  All initialized variables (declarations) declared in a program (e.g., float salary=123.45;).</li>
<li>bss – The BSS consists of uninitialized data such as arrays that you have not set any values to or null pointers.</li>
</ul>
<h2 id="处理器的栈帧布局"><a href="#处理器的栈帧布局" class="headerlink" title="处理器的栈帧布局"></a>处理器的栈帧布局</h2><p>在函数调用内存分配期间隐式构造的堆栈帧。显式地，可以分别使用malloc（）、calloc（）、realloc（）、new、free（）和delete从堆区域请求内存分配并释放到堆区域。堆栈帧的典型布局如下所示，尽管在不同的操作系统中可能会有不同的组织：</p>
<ul>
<li>Function parameters.</li>
<li>Function’s return address.</li>
<li>Frame pointer.</li>
<li>Exception Handler frame.</li>
<li>Locally declared variables.</li>
<li>Buffer.</li>
<li>Callee save registers.</li>
</ul>
<p>堆栈中的排列如下图所示。</p>
<p>![Typical illustration of a stack layout during the function call](D:\图书馆\visio绘图\Typical illustration of a stack layout during the function call.png)</p>
<p>从布局中可以清楚地看到，缓冲区溢出（如果发生）有机会覆盖在高于缓冲区的内存地址分配的其他变量，即本地声明的变量、异常处理程序帧、帧指针、返回地址和函数参数。我们稍后会详细研究这些问题。<br>作为Windows/Intel中的一个例子，通常在函数调用发生时，数据元素以以下方式存储在堆栈上：</p>
<ol>
<li>函数参数在调用函数之前被push到堆栈上。参数从右向左push。</li>
<li>函数返回地址由x86 CALL指令放在堆栈上，该指令存储EIP寄存器的当前值。</li>
<li>然后，作为EBP寄存器的前一个值的帧指针被放在堆栈上。</li>
<li>如果函数包含try/catch或任何其他异常处理构造，例如SEH（Structured Exception Handling -Microsoft实现），编译器将在堆栈中包含异常处理信息。</li>
<li>接下来是局部声明的变量。</li>
<li>然后将缓冲区分配给临时数据存储。</li>
<li>最后，如果在函数执行期间的任何时候使用被调用者保存寄存器（如ESI、EDI和EBX），则会存储这些寄存器。对于Linux/Intel，这一步是在第4步之后。</li>
</ol>
<p>处理器的栈操作：</p>
<p>有两个CPU寄存器对堆栈的运行非常重要，它们保存调用内存中的数据时所需的信息。他们的名字是32位系统中的ESP和EBP。ESP（扩展堆栈指针）保存顶部堆栈地址。ESP可以直接或间接修改。<font color=blue>直接：使用直接操作</font>，例如（Windows/Intel）：</p>
<blockquote>
<p>There are two CPU registers that are important for the functioning of the stack which hold information that is necessary when calling data residing in the memory. Their names are ESP and EBP in 32 bits system. The ESP (Extended Stack Pointer) holds the top stack address.  ESP is modifiable either directly or indirectly. Directly: by using direct operations for example (Windows/Intel):</p>
</blockquote>
<p><strong><u>ESP： Extended Stack Pointer保存top栈地址</u></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add esp, 0Ch</span><br></pre></td></tr></table></figure>

<p>此指令导致堆栈收缩12个字节。以及</p>
<blockquote>
<p>This instruction causes the stack to shrink by 12 bytes.  And</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub esp, 0Ch</span><br></pre></td></tr></table></figure>

<p>这会导致堆栈增加12个字节。（请记住，这可能会让人感到困惑。事实上，ESP值越大，堆栈的大小就越小，反之亦然，因为堆栈在内存中会随着其变大而向下增长，反之亦然）。</p>
<p><img src="C:%5CUsers%5CZeroX%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200623143312038.png" alt="image-20200623143312038"></p>
<p><font color=blue>间接地：通过使用PUSH将数据元素添加到堆栈或使用POP stack操作从堆栈中移除数据元素</font>。例如：</p>
<blockquote>
<p>That causes the stack to grow by 12 bytes.  (Keep in mind that it may seem confusing.  In fact, the bigger the ESP value, the smaller the stack size and vice versa because the stack grows downwards in memory as it gets bigger and vice versa).</p>
<p>Indirectly: by adding data elements to the stack with PUSH or removing data elements from the stack with POP stack operation.  For example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   ebp    ; Save ebp, put it on the stack</span><br><span class="line">pop    ebp    ; Restore ebp, remove it from the stack</span><br></pre></td></tr></table></figure>

<p>除了指向堆栈顶部（较低的数字地址）的堆栈指针之外，通常还可以使用堆栈帧指针（FP），它保存指向帧内固定位置的地址。在堆栈帧中，可以通过给出本地变量相对于ESP的偏移量来引用它们。但是，随着数据被推到堆栈上并从堆栈中弹出，这些偏移量会发生变化，因此本地变量的引用不一致。因此，许多编译器使用另一个寄存器（通常称为帧指针（FP））来引用局部变量和参数，因为它们与FP的距离不会随push和pop而改变。在英特尔CPU上，EBP（扩展基指针）用于此目的。在Motorola CPU上，除了A7（堆栈指针）之外的任何地址寄存器都可以。由于堆栈的增长方式，实际参数的偏移量为正，而局部变量的偏移量为负，如下所示。让我们检查一下下面的简单C程序。</p>
<blockquote>
<p>In addition to the stack pointer, which points to the top of the stack (lower numerical address); it is often convenient to have a stack frame pointer (FP) which holds an address that point to a fixed location within a frame. Looking at the stack frame, local variables could be referenced by giving their offsets from ESP. However, as data are pushed onto the stack and popped off the stack, these offsets change, so the reference of the local variables is not consistent. Consequently, many compilers use another register, generally called Frame Pointer (FP), for referencing both local variables and parameters because their distances from FP do not change with PUSHes and POPs. On Intel CPUs, EBP (Extended Base Pointer) is used for this purpose. On the Motorola CPUs, any address register except A7 (the stack pointer) will do. Because the way stack grows, actual parameters have positive offsets and local variables have negative offsets from FP as shown below. Let examine the following simple C program.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> parameter1, <span class="keyword">char</span> parameter2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local1 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">char</span> local2 = ‘Z’;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyFunc(<span class="number">7</span>, ‘<span class="number">8</span>’);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="D:\图书馆\visio绘图\Function call memory layout.png" alt="Function call: The memory layout." style="zoom:80%;" />



<p>EBP寄存器是<strong>指向堆栈底部的静态寄存器</strong>。堆栈的底部位于固定地址。更准确地说，EBP寄存器包含堆栈底部的地址，作为相对于执行的函数的偏移量。根据函数的任务，堆栈大小在运行时由内核动态调整。每次调用新函数时，EBP的旧值首先被推送到堆栈上，然后ESP的新值被移到EBP。EBP持有的ESP的这个新值成为检索为新函数调用分配的堆栈部分所需的局部变量的引用基。如前所述，堆栈向下扩展到较低的内存地址。这是许多计算机（包括英特尔、摩托罗拉、SPARC和MIPS处理器）的堆栈增长方式。堆栈指针（ESP）在堆栈上的最后一个地址不是堆栈顶部之后的下一个可用地址。</p>
<p>ESP(Extended Stack Pointer)：指向<strong>栈顶</strong>指针</p>
<p>EBP(Extended Base Pointer)：基址指针寄存器。永远指向系统栈最上面一个栈帧的底部。指向当前指针</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/04/10/%E5%88%9D%E8%AF%86syslog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/%E5%88%9D%E8%AF%86syslog/" class="post-title-link" itemprop="url">初识syslog</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:42:43 / 修改时间：10:52:20" itemprop="dateCreated datePublished" datetime="2020-04-10T09:42:43+08:00">2020-04-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在学习syslog，国内写的很多东西非常零散，看得人云里雾里的，从<a href="https://www.paessler.com/it-explained/syslog" target="_blank" rel="noopener">https://www.paessler.com/it-explained/syslog</a>  找了个文档，写的挺详细的，自己翻译了一下，分享出来共同学习。</p>
<h4 id="什么是syslog"><a href="#什么是syslog" class="headerlink" title="什么是syslog"></a>什么是syslog</h4><p>简介：</p>
<ul>
<li>syslog 表示 <font color='red'>System Logging Protocol</font> 系统日志协议</li>
<li>是一种标准协议，用于发送系统日志或者事件信息到一个特定的服务器上（syslog服务器）</li>
<li>用途：主要用于从各种不同的设备中收集各种设备日志到一个中央位置进行监控和查看</li>
</ul>
<p>普适性：</p>
<ul>
<li>syslog协议存在在大多数网络设备上，比如路由器、交换机、防火墙，甚至一些打印机和扫描器上。</li>
<li>在基于Unix、Linux的系统上和很多web服务器（包括Apache）上也有syslog协议</li>
<li>Windows系统默认没有安装syslog，而是使用自己的Windows Event Log（Windows事件日志）。可以使用syslog协议通过第三方实用程序或其他配置转发这些事件。</li>
</ul>
<h4 id="syslog组件"><a href="#syslog组件" class="headerlink" title="syslog组件"></a>syslog组件</h4><blockquote>
<p>在任何给定的设备上，系统都会根据变化的条件生成各种事件。这些事件通常在本地记录，管理员可以对其进行查看和分析。但是，在同等数量的路由器，交换机和系统上监视大量日志将既耗时又不切实际。Syslog通过将这些事件转发到集中式服务器来帮助解决此问题。</p>
</blockquote>
<h4 id="syslog传输"><a href="#syslog传输" class="headerlink" title="syslog传输"></a>syslog传输</h4><p>通常，syslog在514端口上使用UDP协议，也能配置成一个任意端口。此外，某些设备将使用TCP 1468发送系统日志数据以获取确认的消息传递。</p>
<p>syslog报文传输是异步的。路由器、交换机或者服务器自身可以配置去产生syslog message。与其他监视协议（例如SNMP）不同，没有机制可以轮询syslog数据。<br>在某些实现中，SNMP可用于远程设置或修改syslog参数。</p>
<p>syslog message 格式<br>syslog message包括三个部分:</p>
<ul>
<li>PRI: 一个计算的优先值</li>
<li>HEADER: 带有识别信息</li>
<li>MSG： message自身</li>
</ul>
<p>通过syslog协议发送的PRI数据主要由两个值计算而来，PRI主要是为了对message进行分类</p>
<ul>
<li><p>Facility value：设备值或设施值。</p>
<ul>
<li><p>这个值要么是15个预定义的值之一，要么是在16到23的情况下是各种本地定义的值。</p>
</li>
<li><p>作用：用来区分message的类型或者判断哪个系统产生的这个事件。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Kernel messages</td>
</tr>
<tr>
<td>1</td>
<td>User-level messages</td>
</tr>
<tr>
<td>2</td>
<td>Mail System</td>
</tr>
<tr>
<td>3</td>
<td>System Daemons</td>
</tr>
<tr>
<td>4</td>
<td>Security/Authorization Messages</td>
</tr>
<tr>
<td>5</td>
<td>Messages generated by syslogd</td>
</tr>
<tr>
<td>6</td>
<td>Line Printer Subsystem</td>
</tr>
<tr>
<td>7</td>
<td>Network News Subsystem</td>
</tr>
<tr>
<td>8</td>
<td>UUCP Subsystem</td>
</tr>
<tr>
<td>9</td>
<td>Clock Daemon</td>
</tr>
<tr>
<td>10</td>
<td>Security/Authorization Messages</td>
</tr>
<tr>
<td>11</td>
<td>FTP Daemon</td>
</tr>
<tr>
<td>12</td>
<td>NTP Subsystem</td>
</tr>
<tr>
<td>13</td>
<td>Log Audit</td>
</tr>
<tr>
<td>14</td>
<td>Log Alert</td>
</tr>
<tr>
<td>15</td>
<td>Clock Daemon</td>
</tr>
<tr>
<td>16 - 23</td>
<td>Local Use 0 - 7</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Severity Value：严重度值</p>
<ul>
<li><p>syslog消息的第二个标签将消息的重要性或严重性按照从0到7的数字代码进行分类。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>严重性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Emergency</td>
<td>System is unusable</td>
</tr>
<tr>
<td>1</td>
<td>Alert</td>
<td>Action must be taken immediately</td>
</tr>
<tr>
<td>2</td>
<td>Critical</td>
<td>Critical conditions</td>
</tr>
<tr>
<td>3</td>
<td>Error</td>
<td>Error conditions</td>
</tr>
<tr>
<td>4</td>
<td>Warning</td>
<td>Warning conditions</td>
</tr>
<tr>
<td>5</td>
<td>Notice</td>
<td>Normal but significant condition</td>
</tr>
<tr>
<td>6</td>
<td>Informational</td>
<td>Informational messages</td>
</tr>
<tr>
<td>7</td>
<td>Debug</td>
<td>Debug-level messages</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：两个标签的值都没有硬性定义。因此，由系统或应用程序确定如何记录事件（例如，作为警告，通知或其他方式）以及在哪个设施上记录事件。在同一应用程序或服务中，相对于特定过程，较低的数字应对应于更严重的问题（数字越小，问题越严重）</p>
</blockquote>
<p>将这两个值合并以生成随消息发送的优先级值PRI。<br>优先级值是通过将设施值Facility value乘以8，然后将严重性值加到结果中来计算的。<br><strong>PRI越低，优先级越高。</strong></p>
<p><code>(Facility Value * 8) + Severity Value = PRI</code></p>
<p>这样，无论日志警报的严重性如何，内核消息接收的值都比日志警报的值低（优先级更高）。<br>数据包中的其他标识符包括主机名，IP地址，进程ID，应用程序名称和消息的时间戳。</p>
<h4 id="syslog-message示例"><a href="#syslog-message示例" class="headerlink" title="syslog message示例"></a>syslog message示例</h4><h4 id="syslog-server"><a href="#syslog-server" class="headerlink" title="syslog server"></a>syslog server</h4><p>syslog server也叫做syslog collector或者syslog receiver<br>设备产生syslog message，发送给syslog collector。目的syslog服务器必须要在设备中进行配置，或者用命令行配置或者用配置文件配置。一旦配置好之后，所有的syslog数据就会发送给指定的syslog服务器。syslog协议内没有机制可让其他服务器请求syslog数据。</p>
<p>syslog协议可以生成很多消息。<br>Syslog仅在生成消息时就转发消息。<br>因此，系统日志服务器最重要的功能是能够正确过滤传入的系统日志数据并对其做出反应。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/01/20/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%B8%88/" class="post-title-link" itemprop="url">如何成为一名更好的软件架构师</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-20 11:21:40 / 修改时间：11:55:18" itemprop="dateCreated datePublished" datetime="2020-01-20T11:21:40+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="如何成为一名更好的软件架构师"><a href="#如何成为一名更好的软件架构师" class="headerlink" title="如何成为一名更好的软件架构师"></a>如何成为一名更好的软件架构师</h2><p>很多年以前，我曾被追问：“你是如何成为一名软件架构师的？” 我们讨论了成为一名软件架构师所必要的技能，经验以及积累知识所需的时间和奉献精神。此外，我回顾了在成为一名架构师的路上我所走过的路，我所使用过的技术以及从我的职业和非职业生涯中所学到的一切。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr>
<ul>
<li>什么是软件架构师</li>
<li>架构层级</li>
<li>软件架构的典型活动</li>
<li>软件架构的重要技巧</li>
<li>架构师技术路线图</li>
</ul>
<h3 id="什么是软件架构师"><a href="#什么是软件架构师" class="headerlink" title="什么是软件架构师"></a>什么是软件架构师</h3><p>在正式开始之前，我们先来看两个概念：</p>
<ul>
<li>软件架构师是一位软件专家，他可以进行高层设计选择并决定技术标准，包括软件编码标准，工具和平台。这位首席专家被称为首席架构师。（来源：维基百科：软件架构）</li>
<li>软件体系结构是系统的基本组织，由其组件，它们之间的相互关系以及与环境的关系以及确定系统设计和演进的原理来表示。（来源：软件架构手册）</li>
</ul>
<h3 id="架构层级"><a href="#架构层级" class="headerlink" title="架构层级"></a>架构层级</h3><p>架构可以在很多抽象层级上进行分类。架构层级影响着必要技巧的重要性。存在很多可能的分类，我本人比较喜欢按照以下三个层级来划分：</p>
<ul>
<li>应用级：架构的最低层级。只关注单个应用程序。非常详细的底层设计。沟通通常发生在一个开发团队之中</li>
<li>解决方案级：架构的中间层。关注满足业务需求（业务级解决方案）的一个或多个应用程序。很多高层次的底层设计。交流主要发生在多个开发团队之间。</li>
<li>企业级：架构的最高级别。关注多个解决方案。高级抽象设计，需要用解决方案级结构或者应用级架构对其进行详细说明。交流贯穿整个组织。</li>
</ul>
<p>有时候架构师也被视为不同利益相关者之间的“胶水”。三个例子：</p>
<ul>
<li>横向：桥接业务与开发人员或不同开发团队之间的沟通。</li>
<li>纵向：桥接开发者与管理者之间的沟通。</li>
<li>技术：集成不同的技术和应用程序</li>
</ul>
<h3 id="软件架构的典型活动"><a href="#软件架构的典型活动" class="headerlink" title="软件架构的典型活动"></a>软件架构的典型活动</h3><p>要了解架构师所需的必要技能，我们首先需要了解典型活动。以下（非最终）清单是从我的角度给出的一些最重要的活动：</p>
<ul>
<li>定义并确定开发技术和平台</li>
<li>定义开发标准</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/01/19/Structure-and-Interpretation-of-Computer-Programs-second-edition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/19/Structure-and-Interpretation-of-Computer-Programs-second-edition/" class="post-title-link" itemprop="url">Structure and Interpretation of Computer Programs [second edition]</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-19 16:08:39" itemprop="dateCreated datePublished" datetime="2020-01-19T16:08:39+08:00">2020-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-20 11:37:07" itemprop="dateModified" datetime="2020-01-20T11:37:07+08:00">2020-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机程序的构造与解释-第2版"><a href="#计算机程序的构造与解释-第2版" class="headerlink" title="计算机程序的构造与解释[第2版]"></a>计算机程序的构造与解释[第2版]</h1><h2 id="Chapter-1-Building-Abstraction-with-Procedures"><a href="#Chapter-1-Building-Abstraction-with-Procedures" class="headerlink" title="Chapter 1 Building Abstraction with Procedures"></a>Chapter 1 Building Abstraction with Procedures</h2><p>1.1 程序的元素<br>每种语言在实现上基本都包含以下机制：</p>
<ul>
<li>基本表达式</li>
<li>组合的方式</li>
<li>抽象方式</li>
</ul>
<p>编程中主要处理两种元素：<strong>procedures</strong> 和 <strong>数据</strong>。 数据是我们所要操作的对象，procedure是操作这些数据的规则的描述。每种语言都应该能够描述基本数据和基本过程，也应该有组合和抽象这些数据、procedure的方法。</p>
<p>1.1.1 Expressions</p>
<p>😰</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/01/17/ICS%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/ICS%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">ICS入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-17 18:48:19" itemprop="dateCreated datePublished" datetime="2020-01-17T18:48:19+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-20 11:37:07" itemprop="dateModified" datetime="2020-01-20T11:37:07+08:00">2020-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ICS-入门"><a href="#ICS-入门" class="headerlink" title="ICS 入门"></a>ICS 入门</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/01/17/Electron%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/17/Electron%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F/" class="post-title-link" itemprop="url">Electron安装配置淘宝镜像</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-17 12:55:13 / 修改时间：12:58:10" itemprop="dateCreated datePublished" datetime="2020-01-17T12:55:13+08:00">2020-01-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Electron安装配置淘宝镜像"><a href="#Electron安装配置淘宝镜像" class="headerlink" title="Electron安装配置淘宝镜像"></a>Electron安装配置淘宝镜像</h1><p>npm config edit添加以下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">sass_binary_site&#x3D;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass&#x2F;</span><br><span class="line">phantomjs_cdnurl&#x3D;http:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;phantomjs</span><br><span class="line">electron_mirror&#x3D;http:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/01/15/test-my-site/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/test-my-site/" class="post-title-link" itemprop="url">test_my_site</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-15 19:41:07" itemprop="dateCreated datePublished" datetime="2020-01-15T19:41:07+08:00">2020-01-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zeroxln.github.io/2020/01/11/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZeroX">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerohacker.me">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/11/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-11 13:48:40" itemprop="dateCreated datePublished" datetime="2020-01-11T13:48:40+08:00">2020-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZeroX</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZeroX</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
